#!/usr/bin/env python
# coding: utf-8

# In[ ]:


#import the necessary libraries and modules

֫import io
import os
import openai
import random
import requests
import pandas as pd
from dotenv import load_dotenv
from rasa_sdk import Action, Tracker 
from typing import Any, Text, Dict, List
from rasa_sdk.executor import CollectingDispatcher


# Next, we will define a function called get_answers_from_chatgpt. This function takes user_text as input and returns the response generated by ChatGPT.
# 
# To get a response from ChatGPT, we first need to set our OpenAI API key using the os.getenv function.  We will then create 
# a new instance of the OpenAI Completion API and set the engine to “text-davinci-004”, which is one of the most advanced language models available.

# In[ ]:


def get_answers_from_chatgpt(user_text):  #This function takes user_text as input and returns the response generated by ChatGPT.

    # OpenAI API Key
    openai.api_key = os.getenv("OPENAI_API_KEY")  #set our OpenAI API key using the getenv()

    # Use OpenAI API to get the response for the given user text and intent
    response = openai.Completion.create(
        engine="text-davinci-004",        # we can also write, model ="gpt-4"
        prompt= user_text,
        max_tokens=1024,    # maximum number of tokens (words) in the response
        n=1,                # number of responses generated 
        stop=None,
        temperature=0.5,
    ).choices[0].text

    # Return the response from OpenAI
    return response


# We will then use the OpenAI API to generate a response to the user_text input.
# 
# The max_tokens parameter controls the maximum number of tokens (words) in the response, and the n parameter controls the number of responses generated.
# 
# The stop parameter controls the stopping sequence (if any) for the response generation, and the temperature parameter controls the “creativity” of the response.
# 
# Once we have the response from ChatGPT, we will return it to the calling function.
# 
# Next, we will define a new class called Simple_ChatGPT_Action. This class will inherit from the Action class and implement a run method that takes in a dispatcher, tracker, and domain as inputs.

# In[ ]:


class Simple_ChatGPT_Action(Action): #define a new class Simple_ChatGPT_Action. This class will inherit from the Action class
 
    """Rasa action to parse user text and pulls a corresponding answer 
    from ChatGPT."""

    def name(self) -> Text:
        return "action_chatgpt_response" 

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        # Get the latest user text 
        user_text = tracker.latest_message.get('text')
    
        # Dispatch the response from OpenAI to the user
        dispatcher.utter_message('ChatGPT (custom_action): ' + get_answers_from_chatgpt(user_text))

        return []  #empty list indicating the completed action


# The run method will get the tracker object's latest user text and intent. We will then pass the user text to the get_answers_from_chatgpt function and use the CollectingDispatcher object to send the response generated by ChatGPT to the user.
# 
# Finally, we will return an empty list indicating the completed action.
# 
# Once we have integrated the above code into our actions.py file, we can use it to generate responses to user queries using ChatGPT.

# In[ ]:




